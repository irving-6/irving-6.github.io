<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java8新特性</title>
      <link href="/2023/06/01/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2023/06/01/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。<br>为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用<code>default </code>或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。<br>一个interface中可以有多个方法被它们修饰，这2个修饰符的区别主要也是普通方法和静态方法的区别。</p><ol><li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写。</li><li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用。</li></ol><p>我们来看一个实际的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceNew</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sm2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//须要实现类重写</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceNew1</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InterfaceNew1 default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有一个类即实现了<code>InterfaceNew</code>接口又实现了<code>InterfaceNew1</code>接口，它们都有<code>def（）</code>，并且<code>InterfaceNew</code>接口和<code>InterfaceNew1</code>接口没有继承关系的话，这时就必须重写<code>def（）</code>。不然的话，编译的时候就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceNewImpl</span> <span class="keyword">implements</span> <span class="title class_">InterfaceNew</span> , InterfaceNew1&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InterfaceNewImpl</span> <span class="variable">interfaceNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceNewImpl</span>();</span><br><span class="line">        interfaceNew.def();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        InterfaceNew1.<span class="built_in">super</span>.def();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在Java8中，接口和抽象类有什么区别？</strong><br>很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”<br>其实它们还是有区别的</p><ol><li>interface 和 class 的区别，好像是废话，主要有：</li></ol><ul><li>接口多实现，类单继承</li><li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li></ul><ol start="2"><li>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</li></ol><p>开始我们也提到，interface 新增default和static修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代abstract class。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。<br><strong>记住接口永远和类不一样。</strong></p><h2 id="functional-interface-函数式接口"><a href="#functional-interface-函数式接口" class="headerlink" title="functional interface 函数式接口"></a>functional interface 函数式接口</h2><p><strong>定义：</strong>也称SAM接口，即Single Abstract Method interfaces，有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<br>在java8中专门有一个包放函数式接口<code>java.util.function</code>，该包下的所有接口都有<code>@FunctionalInterface</code>注解，提供函数式编程。<br>在其他包中也有函数式接口，其中一些没有<code>@FunctionalInterface</code>注解，但是只要符合函数式接口的定义就是函数式接口，与是否有<code>@FunctionalInterface</code>注解无关，注解只是在编译时起到强制规范定义的作用。其在Lambda表达式中有广泛的应用。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>使用Lambda表达式可以使代码变的更加简洁紧凑。让Java也能支持简单的函数式编程。</p><blockquote><p>Lambda表达式是一个匿名函数，Java8允许把函数作为参数传递进方法中。</p></blockquote><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression 或</span><br><span class="line">(parameters) -&gt; &#123; statements;&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda实战"><a href="#Lambda实战" class="headerlink" title="Lambda实战"></a>Lambda实战</h3><p>过去给方法传动态参数的唯一方法是使用内部类。比如</p><ol><li>Runnable接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The runable now is using!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">//用lambda</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;It&#x27;s a lambda function!&quot;</span>)).start();</span><br></pre></td></tr></table></figure><ol start="2"><li>Listener接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">button.addItemListener(<span class="keyword">new</span> <span class="title class_">ItemListener</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">itemStateChanged</span><span class="params">(ItemEvent e)</span> &#123;</span><br><span class="line">   e.getItem();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line">button.addItemListener(e -&gt; e.getItem());</span><br></pre></td></tr></table></figure><ol start="3"><li>Comparator接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; strings = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(strings, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> o1 - o2;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda</span></span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - o2);</span><br><span class="line"><span class="comment">//分解开</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = (Integer o1, Integer o2) -&gt; o1 - o2;</span><br><span class="line">Collections.sort(strings, comparator);</span><br></pre></td></tr></table></figure><ol start="4"><li>自定义接口</li></ol><p>上面的 3 个例子是我们在开发过程中最常见的，从中也能体会到 Lambda 带来的便捷与清爽。它只保留实际用到的代码，把无用代码全部省略。那它对接口有没有要求呢？我们发现这些匿名内部类只重写了接口的一个方法，当然也只有一个方法须要重写。这就是我们上文提到的函数式接口，也就是说只要方法的参数是函数式接口都可以用 Lambda 表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们自定义一个函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaInterface</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEg</span><span class="params">()</span> &#123;</span><br><span class="line">        lambdaInterfaceDemo(()-&gt; System.out.println(<span class="string">&quot;自定义函数式接口&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数式接口参数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lambdaInterfaceDemo</span><span class="params">(LambdaInterface i)</span>&#123;</span><br><span class="line">        i.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口迭代"><a href="#接口迭代" class="headerlink" title="接口迭代"></a>接口迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lamndaFor</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">//传统foreach</span></span><br><span class="line">        <span class="keyword">for</span> (String s : strings) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Lambda foreach</span></span><br><span class="line">        strings.forEach((s) -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        strings.forEach(System.out::println);</span><br><span class="line"> <span class="comment">//map</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.forEach((k,v)-&gt;System.out.println(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>Java8允许使用<code>：：</code>关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是functional-interface</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    LambdaInterface <span class="title function_">sf</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClass</span> <span class="keyword">extends</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LambdaInterface <span class="title function_">staticF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LambdaInterface <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.调用静态函数，返回类型必须是functional-interface</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">t</span> <span class="operator">=</span> LambdaClass::staticF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.实例方法调用</span></span><br><span class="line">        <span class="type">LambdaClass</span> <span class="variable">lambdaClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaClass</span>();</span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">lambdaInterface</span> <span class="operator">=</span> lambdaClass::f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.超类上的方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">superf</span> <span class="operator">=</span> <span class="built_in">super</span>::sf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 构造方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">tt</span> <span class="operator">=</span> LambdaClassSuper::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Collections.sort(strings,(Integer o1,Integer o2) -&gt; o1-i);</span><br></pre></td></tr></table></figure><p>lambda表达式可以引用外边变量，但是该变量默认拥有final属性，不能被修改，如果修改，编译时就报错。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p> java 新增了<code>java.util.stream</code>包，它和之前的流大同小异。之前接触最多的是资源流，比如<code>java.io.FileInputStream</code>，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何_CRUD_。<br><code>Stream</code>依然不存储数据，不同的是它可以检索（Retrieve）和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是sql语句。<br>它的源数据可以是<code>Collection</code>、<code>Array</code>等。由于它的方法参数都是函数式接口类型，所以一般都是和Lambda配合使用。</p><h3 id="流类型"><a href="#流类型" class="headerlink" title="流类型"></a>流类型</h3><ol><li>stream串行流</li><li>parallelStream并行流，可多线程执行</li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个串行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个并行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回T的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回其元素是指定值的顺序流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 过滤，返回由与给定predicate匹配的该流的元素组成的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流的所有元素是否与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流任意元素是否有与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个 Stream的构建器。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Builder&lt;T&gt; <span class="title function_">builder</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Collector对此流的元素进行归纳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此流中的元素数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于获取指定数量的流，截短长度不能超过 maxSize 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于映射每个元素到对应的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据提供的 Comparator进行排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个包含此流的元素的数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用提供的 generator函数返回一个包含此流的元素的数组，</span></span><br><span class="line"><span class="comment">以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 合并流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;gkh&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//返回符合条件的stream</span></span><br><span class="line">        Stream&lt;String&gt; stringStream = strings.stream().filter(<span class="string">&quot;abc&quot;</span>::equals);</span><br><span class="line">        <span class="comment">//或者 strings.stream().filter(s-&gt;&quot;abc&quot;.equals(s));</span></span><br><span class="line">        <span class="comment">//输出[abc, abc]</span></span><br><span class="line">        <span class="comment">//System.out.println(stringStream.collect(Collectors.toList()));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringStream.count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">        strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//limit 获取到1个元素的stream</span></span><br><span class="line">        Stream&lt;String&gt; limit = strings.stream().limit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span></span><br><span class="line">        String[] array = limit.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : array) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//map  对每个元素进行操作返回新流</span></span><br><span class="line">        strings.stream().map(s-&gt;s+<span class="string">&quot;22&quot;</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sorted 排序并打印</span></span><br><span class="line">        strings.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Collectors collect 把abc放入容器中</span></span><br><span class="line">        List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());</span><br><span class="line">        collect.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把List转为string，各元素用，号分隔开 abc,def,gkh,abc</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">collect1</span> <span class="operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对数组的统计，比如用</span></span><br><span class="line">        List&lt;Integer&gt; number = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> number.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span>+statistics.getMax());</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span>+statistics.getMin());</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数 : &quot;</span>+statistics.getAverage());</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数之和 : &quot;</span>+statistics.getSum());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//concat 合并流</span></span><br><span class="line">        List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;jqx&quot;</span>);</span><br><span class="line">        Stream.concat(strings2.stream(),strings.stream()).count();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意 一个Stream只能操作一次，不能断开，否者会报错</span></span><br><span class="line">        <span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> strings.stream();</span><br><span class="line">        <span class="comment">//第一次使用</span></span><br><span class="line">        <span class="comment">//stream.limit(2);</span></span><br><span class="line">        <span class="comment">//第二次使用</span></span><br><span class="line">        <span class="comment">//stream.forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//报错java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line">        <span class="comment">//但是可以连续使用</span></span><br><span class="line">        stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>在执行返回<code>Stream</code>的方法时，并不立刻执行，而是等返回一个非<code>Stream</code>的方法后才执行。因为拿到<code>Stream</code>并不能直接用，而是需要处理成一个常规类型。这里的<code>Stream</code>可以想象成是二进制流（2个完全不一样的东西），拿到也看不懂。<br>下面分解一下<code>filter</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">laziness</span><span class="params">()</span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  Stream&lt;Integer&gt; stream = strings.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Predicate.test 执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">&quot;count 执行&quot;</span>);</span><br><span class="line">   stream.count();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------执行结果--------*/</span></span><br><span class="line">count 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br></pre></td></tr></table></figure><p>按执行顺序应该是先打印 4 次「<code>Predicate.test</code> 执行」，再打印「<code>count</code> 执行」。实际结果恰恰相反。说明 <code>filter</code> 中的方法并没有立刻执行，而是等调用<code>count()</code>方法后才执行。<br>上面都是串行<code>Stream</code>的实例。并行<code>parallelStream</code>在使用方法上和串行一样。主要区别是<code>parallelStream</code>可多线程执行，是基于ForkJoin框架实现的，有时间大家可以了解一下 ForkJoin 框架和 ForkJoinPool。这里可以简单的理解它是通过线程池来实现的，这样就会涉及到线程安全，线程消耗等问题。下面我们通过代码来体验一下并行流的多线程执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parallelStreamTest</span><span class="params">()</span>&#123;</span><br><span class="line">   List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">   numbers.parallelStream() .forEach(num-&gt;System.out.println(Thread.currentThread().getName()+<span class="string">&quot;&gt;&gt;&quot;</span>+num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">main&gt;&gt;<span class="number">5</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">2</span>&gt;&gt;<span class="number">4</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">11</span>&gt;&gt;<span class="number">1</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">9</span>&gt;&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure><p>从结果中我们看到，for-each 用到的是多线程。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。</li><li>方法参数都是函数式接口类型</li><li>一个Stream只能操作一次，操作完就关闭了，继续使用这个stream会报错。</li><li>stream不保存数据，不改变数据源</li></ol><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p><a href="https://share.weiyun.com/ThuqEbD5">阿里巴巴开发手册关于 Optional 的介绍</a></p><blockquote><p>防止NPE，是程序员的基本修养，注意NPE产生的场景：</p><ol><li>返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE</li></ol><p>反例：public int f(){return Integer对象}，如果为null，自动拆箱抛NPE</p><ol start="2"><li>数据库的查询结果可能为NULL</li><li>集合里的元素即使isNotEmpty，取出的数据元素也可能为NULL</li><li>远程调用返回对象时，一律要求进行空指针判断，防止NPE</li><li>对于session中获取的数据，建议进行NPE检查，避免空指针</li><li>级联调用obj.getA().getB().getC()；一连串调用，易产生NPE</li></ol><p>正例：使用JDK8的Optional类来防止NPE问题。</p></blockquote><p>他建议使用<code>Optional</code>解决NPE（<code>java.lang.NullPointerException</code>）问题，它就是为NPE而生的，其中可以包含空值或非空值。下面我们通过源码逐步揭开<code>Optional</code>的红盖头<br>假设有一个<code>Zoo</code>类，里面有个属性<code>Dog</code>，需求要获取<code>Dog</code>的<code>age</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">zoo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传统解决NPE的办法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Zoo</span> <span class="variable">zoo</span> <span class="operator">=</span> getZoo();</span><br><span class="line"><span class="keyword">if</span>(zoo !=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> zoo.getDog();</span><br><span class="line">    <span class="keyword">if</span>(dog!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dog.getAge();</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层层判断对象非空，有人说这种方式很丑陋不优雅，并不这么认为。反而觉得很整洁易懂。<br><code>Optional</code>是这样实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(zoo).map(o-&gt;o.getDog()).map(d-d.getAge())</span><br><span class="line">    .ifPresent(age-&gt;System.out.println(age)</span><br><span class="line">               );</span><br></pre></td></tr></table></figure><h3 id="如何创建一个Optional"><a href="#如何创建一个Optional" class="headerlink" title="如何创建一个Optional"></a>如何创建一个Optional</h3><p>上例中<code>Optional.ofNullable</code>是其中一种创建Optional的方式。我们先看一下它的含义和其他创建Optional的源码方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Common instance for &#123;<span class="doctag">@code</span> empty()&#125;. 全局EMPTY对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Optional维护的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value是null就返回EMPTY，否则就返回of(T)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 EMPTY 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">   Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回Optional对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 私有构造方法，给value赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Optional</span><span class="params">(T value)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ofNullable </code>方法和<code>of</code>方法唯一区别就是当 <code>value</code> 为 <code>null</code> 时，<code>ofNullable</code> 返回的是<code>EMPTY</code>，<code>of</code> 会抛出 <code>NullPointerException</code> 异常。如果需要把 <code>NullPointerException</code> 暴漏出来就用 <code>of</code>，否则就用 <code>ofNullable</code>。</p><h3 id="map-相关方法"><a href="#map-相关方法" class="headerlink" title="map()相关方法"></a>map()相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value为null，返回EMPTY，否则返回Optional封装的参数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(mapper);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> empty();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value为null，返回EMPTY，否则返回Optional封装的参数值，</span></span><br><span class="line"><span class="comment">如果参数值返回null会抛NullPointerException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(mapper);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> empty();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map()</code>和<code>flatMap()</code>有什么区别？</p><ol><li>参数不一样，<code>map</code>的参数上面看到过，<code>flatMap</code>的参数是这样</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooFlat</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">DogFlat</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogFlat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DogFlat <span class="title function_">getDog</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dog;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogFlat</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> Optional&lt;Integer&gt; <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(age);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ZooFlat</span> <span class="variable">zooFlat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooFlat</span>();</span><br><span class="line">Optional.ofNullable(zooFlat).map(o -&gt; o.getDog()).flatMap(d -&gt; d.getAge()).ifPresent(age -&gt;</span><br><span class="line">    System.out.println(age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>flatMap()</code>参数返回值如果是null会抛<code>NullPointerException</code>，而<code>map()</code>返回<code>EMPTY</code></li></ol><h3 id="判断value是否为null"><a href="#判断value是否为null" class="headerlink" title="判断value是否为null"></a>判断value是否为null</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* value是否为null</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value !=<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value不为null执行consumer.accept</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">    consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取value"><a href="#获取value" class="headerlink" title="获取value"></a>获取value</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the value if present, otherwise invoke &#123;<span class="doctag">@code</span> other&#125; and return</span></span><br><span class="line"><span class="comment">* the result of that invocation.</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则返回other的执行结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则返回T</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则抛出参数返回的异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value为null抛出NoSuchElementException，不为空返回value。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤值"><a href="#过滤值" class="headerlink" title="过滤值"></a>过滤值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 如果是empty返回empty</span></span><br><span class="line"><span class="comment">* 2. predicate.test(value)==true 返回this，否则返回empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>看完<code>Optional</code>源码，<code>Optional</code>的方法真的非常简单，值得注意的是如果坚决不想看见<code>NPE</code>，就不要用<code>of()</code>、<code>get（）</code>、<code>flatMap（）</code>。最后再综合一下<code>Optional</code>的高频方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(zoo).map(o-&gt;o.getDog())</span><br><span class="line">    .map(d-d.getAge()).filter(v-&gt;v==<span class="number">1</span>).orElse(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a>Date-Time API</h2><p>这是对<code>java.util.Date</code>强有力的补充，解决了Date类的大部分痛点：</p><ol><li>非线程安全</li><li>时区处理麻烦</li><li>各种格式化、和时间计算繁琐</li><li>设计有缺陷，Date类同时包含日期和时间；还有一个java.sql.Date，容易混淆。</li></ol><p>我们从常用的时间实例来对比java.util.Date和新Date有什么区别。用<code>java.util.Date</code>的代码该改改了。</p><h3 id="java-time主要类"><a href="#java-time主要类" class="headerlink" title="java.time主要类"></a>java.time主要类</h3><p><code>java.util.Date</code> 既包含日期又包含时间，而 <code>java.time</code> 把它们进行了分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.class <span class="comment">//日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS</span></span><br><span class="line">LocalDate.class <span class="comment">//日期 format: yyyy-MM-dd</span></span><br><span class="line">LocalTime.class <span class="comment">//时间 format: HH:mm:ss</span></span><br></pre></td></tr></table></figure><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>Java8之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span>  <span class="operator">=</span> sdf.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdft.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdfdt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">datetime</span> <span class="operator">=</span> sdfdt.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, datetime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java8之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now().withNano(<span class="number">0</span>);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateTimeStr</span> <span class="operator">=</span> dateTime.format(dateTimeFormatter);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, dateTimeStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串转日期格式"><a href="#字符串转日期格式" class="headerlink" title="字符串转日期格式"></a>字符串转日期格式</h3><p>java8之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已弃用</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2021-01-26&quot;</span>);</span><br><span class="line"><span class="comment">//替换为</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2021-01-26&quot;</span>);</span><br></pre></td></tr></table></figure><p>Java8之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">26</span>);</span><br><span class="line">LocalDate.parse(<span class="string">&quot;2021-01-26&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">26</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">LocalDateTime.parse(<span class="string">&quot;2021-01-26 12:12:22&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">LocalTime.parse(<span class="string">&quot;12:12:22&quot;</span>);</span><br></pre></td></tr></table></figure><p>Java8之前转换都需要借助<code>SimpleDateFormat</code>类，而Java8之后只需要<code>LocalDate``LocalTime``LocalDateTime</code>的<code>of</code>或<code>parse</code>方法。</p><h3 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/06/01/2023-6-1/"/>
      <url>/2023/06/01/2023-6-1/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
